#include <WiFiNINA.h>
// WiFiNINA - Version: Latest 

// Arduino_MKRRGB - Version: Latest 
#include <Arduino_MKRRGB.h>

// Arduino_MKRIoTCarrier - Version: Latest 
#include <Arduino_MKRIoTCarrier.h>
#include <Arduino_MKRIoTCarrier_Buzzer.h>
#include <Arduino_MKRIoTCarrier_Qtouch.h>
#include <Arduino_MKRIoTCarrier_Relay.h>

/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled"
  https://create.arduino.cc/cloud/things/224ab036-1a9e-4ea3-b8d5-02e5560f549f 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  bool light_alarm;
  bool light_event;
  bool movement_event;
  bool shake_event;
  String message_update;
  bool movement_alarm;
  bool shake_alarm;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
  
MKRIoTCarrier carrier;


int pir = A5;
int pirState = 0;
 
int light = 0;
 
String light_alarm_state = "";
String movement_alarm_state = "";
String shake_alarm_state = "";
 
float Gx, Gy, Gz;
 
uint32_t redColor = carrier.leds.Color( 0, 255, 0);
uint32_t noColor = carrier.leds.Color( 0, 0, 0);
 
void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
 // while (!Serial);
 
  // Defined in thingProperties.h
  initProperties();
 
  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  //Get Cloud Info/errors , 0 (only errors) up to 4
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();
 
  //Wait to get cloud connection to init the carrier
  while (ArduinoCloud.connected() != 1) {
    ArduinoCloud.update();
    delay(500);
  }
 
  delay(500);
  CARRIER_CASE = true;
  carrier.begin();
  carrier.display.setRotation(0);
  delay(1500);
  pinMode(A5, INPUT);
 
}

void loop() {
  ArduinoCloud.update();
  // Your code here 
 
 pirState = digitalRead(pir);
 
  while (!carrier.Light.colorAvailable()) {
    delay(5);
  }
  int none; //not gonna be used
  carrier.Light.readColor(none, none, none, light);
 
  // read the IMU values
  carrier.IMUmodule.readGyroscope(Gx, Gy, Gz);
 
  //Uncomment this code to see values in Serial Monitor
  /*
    Serial.print("Gyroscope: ");
    Serial.print("\tX: ");
    Serial.print(Gx);
    Serial.print("\tY: ");
    Serial.print(Gy);
    Serial.print("\tZ: ");
    Serial.println(Gz);
 
    Serial.print("Light: ");
    Serial.println(light);
 
    Serial.print("PIR State: ");
    Serial.println(pirState);
 
    delay(200);
  */
 
  //light alarm, can be activated from cloud
  if (light_alarm == true) {
 
    if (light > 200) {
      light_event = true;
    }
 
 
    if (light_event == true) {
      message_update = "Light alarm breached!";
      alarm();
    }
  }
 
  //movement alarm, can be activated from cloud
  if (movement_alarm == true) {
    if (pirState == HIGH) {
      movement_event = true;
    }
 
    if (movement_event == true) {
      message_update = "Movement alarm breached!";
      alarm();
    }
  }
 
  //shake alarm, can be activated from cloud
  if (shake_alarm == true) {
    if (Gy > 100 || Gy < -100) {
      shake_event = true;
    }
 
    if (shake_event == true) {
      message_update = "Shake alarm breached!";
      alarm();
    }
  }
  delay(100);
 
}
 
// the alarm() function blinks the RGB LEDs and turns the buzzer on and off
 
void alarm() {
  carrier.leds.fill(redColor, 0, 5);
  carrier.leds.show();
  carrier.Buzzer.sound(500);
  delay(500);
 
  carrier.leds.fill(noColor, 0, 5);
  carrier.leds.show();
  carrier.Buzzer.noSound();
  delay(500);
}
 
// the updateScreen() function updates the screen whenever an alarm has been activated from the cloud
 
void updateScreen() {
  carrier.display.fillScreen(ST77XX_BLACK);
  carrier.display.setTextColor(ST77XX_WHITE);
  carrier.display.setTextSize(2);
 
  carrier.display.setCursor(25, 60);
  carrier.display.print(light_alarm_state);
  carrier.display.setCursor(10, 100);
  carrier.display.print(movement_alarm_state);
  carrier.display.setCursor(30, 140);
  carrier.display.print(shake_alarm_state);
}
 
void onLightAlarmChange() {
  // Do something
  if (light_alarm == true) {
    light_alarm_state = "LIGHT ALARM: ON";
  } else {
    light_alarm_state = "LIGHT ALARM: OFF";
  }
 
  updateScreen();
}
 
void onShakeAlarmChange() {
  // Do something
  if (shake_alarm == true) {
    shake_alarm_state = "SHAKE ALARM: ON";
  } else {
    shake_alarm_state = "SHAKE ALARM: OFF";
  }
 
  updateScreen();
}
 
void onMovementAlarmChange() {
  // Do something
  if (movement_alarm == true) {
    movement_alarm_state = "MOVEMENT ALARM: ON";
  } else {
    movement_alarm_state = "MOVEMENT ALARM: OFF";
  }
 
  updateScreen();
}
 
 
void onMessageUpdateChange() {
  // Do something
}
void onShakeEventChange() {
  // Do something
}
void onMovementEventChange() {
  // Do something
}
void onLightEventChange() {
  // Do something
}

void onTempAlarmChange() {
  // Do something
}


void onTempEventChange() {
  // Do something
}





